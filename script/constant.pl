#!/usr/bin/perl
# Generate constants from define or enum.

use strict;
use warnings;

# get $VERSION without loading XS code
do "./lib/OPCUA/Open62541.pm";

sub usage {
    print STDERR "usage: perl script/constant.pl define|enum prefix header\n";
    exit 2;
}

usage() unless @ARGV == 3;

my $type = $ARGV[0];
my $prefix = $ARGV[1];
my $header = $ARGV[2];

my $cfile = "/usr/local/include/open62541/$header.h";
open(my $cf, '<', $cfile)
    or die "Open '$cfile' for reading failed: $!";

my $pmfile = "lib/OPCUA/Open62541/$prefix.pm";
open(my $pf, '>', $pmfile)
    or die "Open '$pmfile' for writing failed: $!";

print_header($pf, $prefix, $OPCUA::Open62541::VERSION);

my $ccomment = qr/\/\*.*?(?:\*\/|$)/;  # C comment /* */, may be multiline
my $cdefine = qr/#define\s+UA_${prefix}_(\S+)\s+(.+)/;  # C #define
my $cenum = qr/UA_${prefix}_([^\s,]+)(?:\s*=\s*([^,]+))?\s*,?/;  # C enum, opt

my $regex =
    $type eq 'define' ? qr/^$cdefine\s*$ccomment?\s*$/ :
    $type eq 'enum' ? qr/^\s*$cenum\s*$ccomment?\s*$/ :
    die "Type must be define or enum: $type";

my ($firststr, $prevnum);
$prevnum = -1;  # if enum has no value, it starts with 0
while (<$cf>) {
    my ($str, $num) = /$regex/
	or next;
    # if enum has no value, it increments the previous
    $num //= $prevnum + 1 if $type eq 'enum';
    $num =~ s/(?<=\d)l*u//gi;
    $num = eval "$num";
    print $pf "$str $num\n";
    $firststr ||= $str;
    $prevnum = $num;
}
die "No type $type with prefix $prefix in header $header" unless $firststr;

print_footer($pf, $prefix);
print_pod($pf, $type, $prefix, $header, $firststr);

close($pf)
    or die "Open '$pmfile' after writing failed: $!";

exit 0;

sub print_header {
    my ($pf, $class, $version) = @_;
    print $pf <<"EOHEADER";
# This file has been generated by
# $0 @ARGV

package OPCUA::Open62541::$class;

use 5.015004;
use strict;
use warnings;
use Carp;

our \$VERSION = '$version';

BEGIN {
    my \$class = '$class';

    # Even if we declare more than 10k constants, this is a fast way to do it.
    my \$consts = <<'EOCONST';
EOHEADER
}

sub print_footer {
    my ($pf, $class) = @_;
    print $pf <<'EOFOOTER';
EOCONST

    open(my $fh, '<', \$consts) or croak "open consts: $!";

    local $_;
    my (%hash, $str, $num);
    while (<$fh>) {
	chomp;
	($str, $num) = split;
	$hash{"${class}_${str}"} = $num;
    }

    close($fh) or croak "close consts: $!";

    # This is how "use constant ..." creates constants.  constant.pm checks
    # constant names and non-existance internally.  We know our names are OK
    # and we only declare constants in our own namespace where they don't yet
    # exist.  Therefore we can skip the checks and make this module load
    # faster.
    no strict 'refs';    ## no critic (ProhibitNoStrict)
    my $symtab = \%{"OPCUA::Open62541::"};
    use strict;

    while (my ($name, $scalar) = each %hash) {
	Internals::SvREADONLY($scalar, 1);
	$symtab->{$name} = \$scalar;
    }
    mro::method_changed_in("OPCUA::Open62541");

    require Exporter;
    @OPCUA::Open62541::ISA = qw(Exporter);
    @OPCUA::Open62541::EXPORT_OK = keys %hash;
    %OPCUA::Open62541::EXPORT_TAGS = (all => [keys %hash]);
    sub import {
	OPCUA::Open62541->export_to_level(1, @_);
    }
}

1;

__END__
EOFOOTER
}

sub print_pod {
    my ($pf, $type, $class, $header, $str) = @_;
    print $pf <<"EOPOD";

=head1 NAME

OPCUA::Open62541::$class - $type $class from $header.h

=head1 SYNOPSIS

  use OPCUA::Open62541::$class;

  use OPCUA::Open62541::$class qw(${class}_${str} ...);

  use OPCUA::Open62541::$class ':all';

=head1 DESCRIPTION

This module provides all $class ${type}s as Perl constants.
They have been extracted from the $header.h C source file.

=head2 EXPORT

=over 4

=item ${class}_${str} ...

Export specific $class constants into the OPCUA::Open64541 name
space.

=item :all

Exports all $class constants into the OPCUA::Open64541 name space.
You might want to import only the ones you need.

=back

=head1 SEE ALSO

OPCUA::Open62541

=head1 AUTHORS

Alexander Bluhm,
Arne Becker

=head1 COPYRIGHT AND LICENSE

Copyright (c) 2020 Alexander Bluhm
Copyright (c) 2020 Arne Becker

This is free software; you can redistribute it and/or modify it under
the same terms as the Perl 5 programming language system itself.

Thanks to genua GmbH, https://www.genua.de/ for sponsoring this work.

=cut
EOPOD
}
